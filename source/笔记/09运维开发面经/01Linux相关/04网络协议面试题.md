# 网络协议面试题

## 对称加密与非对称加密

对称加密是指加密和解密使用同一种密钥方式，需要考虑如何安全地将密钥发送给对方；非对称加密是指使用一对非对称密钥，即公钥和私钥，公钥随意发布，私钥只有自己知道，发送密文的一方使用对方的公钥进行加密处理，对方收到加密信息后，使用自己的私钥进行解密。

非对称加密不需要发送用来解密的私钥，可以保证安全性；但和对称加密相比，其非常慢，一般使用对称加密传送消息，但对称加密所使用的密钥可以通过非对称加密的方式发送出去。

## 为什么要三次握手和四次挥手

“三次握手”的目的是防止**已失效的链接请求突然又传送到了服务端**，导致错误。假设不采用三次握手，那么只要 B 发出确认，新的连接就建立了，由于 A 并没有发出建立连接的请求，不会理睬 B 的确认，也不会向 B 发送数据，但 B 认为新的连接已经建立，并一直等待 A 发送数据，B 的资源就被浪费掉了。

“四次挥手”的原因：TCP 是全双工模式，这就意味着，当 A 向 B 发出 FIN 报文段时，只是表示 A 已经没有数据要发送了，而此时 A 还是能接收 B 发出的数据；当 B 向 A 发出 ACK 报文只是告诉 A 已经知道 A 没有数据要发了，但 B 还是能够向 A 发送数据，所以想要愉快的结束这次对话需要四次挥手。

## TCP 协议如何保证传输可靠性

- **数据包校验**：检测数据在传输过程中的变化，若校验包错误，则丢弃报文段并且不给出响应，这时 TCP 发送数据端超时后会重发数据；
- **失效数据包重排序**：TCP 报文段作为 IP 数据报传输，IP 数据报的到达可能会失序，因此 TCP 报文段到达也可能会失序。TCP 将对失序数据进行重新排序，然后交给应用层
- **丢弃重复数据**
- **应答机制**：当TCP收到发自TCP连接另一端的数据，它将发送一个确认。这个确认不是立即发送，通常将推迟几分之一秒；
- **超时重发**：当TCP发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段；
- **流量控制**：TCP连接的每一方都有固定大小的缓冲空间。TCP的接收端只允许另一端发送接收端缓冲区所能接纳的数据，这可以防止较快主机致使较慢主机的缓冲区溢出，这就是流量控制。TCP使用的流量控制协议是可变大小的滑动窗口协议。

## TCP 和 UDP 分别对应的常见应用层协议

### TCP 对应应用层协议

- **FTP**：文件传输协议，使用 21 端口，启动文件传输服务。下载文件，上传主页，都要用到 FTP 服务；
- **Telnet**：远程登录端口，用户可以以自己的身份连接到计算机，这种端口提供一种基于 DOS 模式下的通信服务；
- **SMTP**：简单的邮件传送协议，用于发送邮件。电子邮件设置中常看到有 SMTP 端口设置栏，服务器开放的是 25 号端口；
- **POP3**：与 SMTP 对应，POP3 用于接收邮件。使用 110 端口，只要有相应使用 POP3 协议的程序（如 Fo-xmail 或 Outlook），就可以不以 Web 方式登录邮箱界面，直接用邮件程序可以收到邮件；
- **HTTP**：从 Web 服务器超文本传到本地浏览器的传送协议

### UDP 对应应用层协议

- **DNS**：域名解析服务，将域名转换为 IP 地址，DNS 用的是 53 号端口
- **SNMP**：简单网络管理协议，使用 161 号端口，用来管理网络设备，由于网络设备很多，无连接的优势体现出
- **TFTP**：简单文件传输协议，该协议在熟知端口 69 上使用 UDP 服务

## TCP 拥塞控制机制

拥塞控制：防止过多数据注入到网络中，使得网络中的路由器或链路不致过载，拥塞控制的方法有两种：

### 慢启动 + 拥塞避免

不要一开始发送大量数据，先探测一下网络的拥塞程度，从小到大逐渐增加拥塞窗口的大小

让拥塞窗口缓慢增长，即每经过一个往返时间就把发送方的拥塞窗口加1，这样拥塞窗口按线性规律缓慢增长

### 快重传 + 快恢复

接收方收到一个 **失效的报文段** 后立即发出 **重复确认** ，为的是使发送方及早知道有报文段没有到达对方。快重传算法规定，发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，不必等待设置的重传计时器到期。

当发送方连续收到三个重复确认时，就执行 “乘法减小” 算法，把 ssthresh 门限减半，但接下去并不执行慢启动算法：如果网络出现拥塞的话就不会收到好几个重复的确认，所以发送方认为网络没有拥塞，所以不执行慢启动算法，而是将 cwnd 设置为 ssthresh 的大小，然后执行拥塞避免算法。

## Session、Cookie 与 Application

### Cookie 及其相关 API

如果服务器需要记录客户端的状态，使用 response 向客户端浏览器发送一个 Cookie，客户端把 Cookie 保存下来。当浏览器再请求该网站时，浏览器把请求网站连同 Cookie 一同交给服务器，服务器检查 Cookie 辨认用户状态，服务器还可以根据需要修改 Cookie 的内容。

### Session 及其相关 API

客户端请求服务器，服务器通过 Session 记录并保存用户状态。保存 Sessionid 的方式可以采用 cookie 机制，这样在交互过程中浏览器可以自动按照规则把标识发送给服务器。

### Session 与 Cookie 对比

**实现机制**：Session的实现常常依赖于Cookie机制，通过Cookie机制回传SessionID；

**大小限制**：Cookie有大小限制并且浏览器对每个站点也有cookie的个数限制，Session没有大小限制，理论上只与服务器的内存大小有关；

**安全性**：Cookie存在安全隐患，通过拦截或本地文件找得到cookie后可以进行攻击，而Session由于保存在服务器端，相对更加安全；

**服务器资源消耗**：Session是保存在服务器端上会存在一段时间才会消失，如果session过多会增加服务器的压力。

### Application

与一个 Web 应用程序相对应，为应用提供一个全局的状态，所有客户都可以使用该状态





