# K8s 基础

虽然 Docker 已经很强大了，但是在实际使用上还是有诸多不便，比如集群管理、资源调度、文件管理等，在容器时代出现了谷歌开源的 Kubernetes，Kubernetes 已经成为容器编排领域的王者，它是基于容器的集群编排引擎，具备扩展集群、滚动升级回滚、弹性收缩、自动自愈、服务发现等多种特性能力。

K8s 的出现不仅主宰了容器编排市场，更改变了过去的运维方式，将开发与运维之间的边界变得更加模糊，每个软件工程师都可以通过 K8s 来定义服务之间的拓扑关系、线上节点个数、资源使用量并且能够快速实现水平扩容、蓝绿部署等在过去复杂的运维操作。

## K8s 解决的核心问题

**服务发现与负载均衡**

K8s 可以使用 DNS 名称或自己的 IP 地址公开容器，如果容器的流量很大，K8s 可以负载均衡并分配网络流量，从而使部署稳定。

**存储编排**

K8s 允许您自动挂载您选择的存储系统，例如本地存储、公共云提供商等。

**自动部署和回滚**

您可以使用 K8s 描述已部署容器的所需状态，它可以以受控的速率将实际状态更改为所需状态。例如，您可以自动化 K8s 来为您的部署创建新的容器，删除现有容器并将它们的所有资源应用于新容器。

**自动二进制打包**

K8s 允许您指定每个容器所需的 CPU 和内存（RAM）。当容器指定了资源请求时，K8s 可以做出更好的决策来管理容器的资源。

**自我修复**

K8s 重新启动失败的容器、替换容器、杀死不响应用户定义的运行状态检查的容器，并且在准备好服务之前不将其通告给客户端。

**密钥与配置管理**

K8s 允许您存储和管理敏感信息，例如密码、OAuth 令牌和 ssh 密钥。您可以在不重建容器镜像的情况下部署和更新密钥和应用程序配置，也无需在堆栈配置中暴露密钥。

## 软件架构

K8s 遵循传统的客户端/服务端架构模式，客户端可以使用 RESTful 接口或者直接使用 kubectl 与 K8s 集群进行通信，这两个在实际上没有太多的区别，后者也只是对 K8s 提供的 RESTful API 进行封装并提供出来。每一个 K8s 集群都是由一组 **Master** 节点和一系列的 **Worker** 节点组成，其中 **Master** 节点主要负责存储集群的状态并为 K8s 对象分配和调度资源。

### 主节点服务——Master 架构

作为集群管理状态的 Master 节点，它主要负责接收客户端的请求，安排容器的执行并且运行控制循环，将集群的状态向目标状态迁移。

- **API Server**：负责处理来自用户的请求，其主要作用就是对外提供 RESTful 接口，包括用于查看集群状态的**读请求**以及改变集群状态的**写请求**，也是唯一一个与 etcd 集群通信的组件。
- **etcd**：是兼具一致性和高可用性的键值数据库，可以作为保存 K8s 所有集群数据的后台数据库。
- **Scheduler**：主节点上的组件，该组件监视那些新创建但未指定运行节点的 Pod，并选择节点让 Pod 在上面运行。调度决策需要考虑单个 Pod 和 Pod 集合的资源需求，硬件/软件/策略约束、亲和性和反亲和性规范、数据位置、工作间负载干扰和最后时限。
- **Controller-manager**：在主节点上运行控制器的组件，从逻辑上讲，每个控制器都是一个单独的进程，但是为了降低复杂性，它们都被编译到同一个可执行文件，并在一个进程中运行。这些控制器包括：节点控制器（负责在节点出现故障时进行通知和响应）、副本控制器（负责为系统中的每个副本控制器对象维护正确数量的 Pod）、端点控制器（填充端点 Endpoints 对象，即加入 Service 与 Pod）、服务账户和令牌控制器（为新的命名空间创建默认账户和 API 访问令牌）。

### 工作节点——Node 架构

Worker 节点的实现相对较为简单，主要由 `kubelet` 和 `kube-proxy` 两部分组成。

- **Kubelet**：是工作节点执行操作的 agent，负责具体的容器生命周期管理，根据从数据库中获取的信息管理容器，并上报 Pod 运行状态等。
- **Kube-proxy**：是一个简单的网络访问代理，同时也是一个 Load-Balancer。它负责将访问到某个服务的请求具体分配给工作节点同一类标签的 Pod。Kube-proxy 实质就是通过操作防火墙规则（iptables 或者 ipvs）来实现 Pod 的映射。
- **Container Runtime**：容器运行环境是负责运行容器的软件，K8s 支持多个容器运行环境：Docker、Containerd、cri-o、rklet 以及任何实现 K8s CRI（容器运行环境接口）

### 资源清单

K8s 所有内容都抽象化为资源，资源实例化后叫做对象。

在 K8s 系统中，K8s 对象是持久化的实体，K8s 使用这些实体去表示整个集群的状态。特别地，它们描述了如下信息：

- 哪些容器化应用在运行，以及在哪个 Node 上
- 可以被应用使用的资源
- 关于应用运行时表现的策略，比如重启策略、升级策略，以及容错策略

K8s 对象是“目标性记录”，一旦创建对象，K8s 系统将持续性工作以确保对象存在。通过创建对象，本质上是在告知 K8s 系统，所需要的集群工作负载是什么样的，这就是 K8s 集群的期望状态。

### 资源控制器

### 服务发现

### Ingress 服务

### 数据存储

### 集群调度

